GRAVITY = .1;
TERMINAL_VELOCITY = .9;

PLAYER_IMAGE_BY_SCALE = {};

class Sprite {
	constructor(type, x, y) {
		this.x = x + 0.0;
		this.y = y + 0.0;
		this.type = type;
		// TODO: better sprite definition system.
		this.width = .75;
		if (type == 'player') {
			this.height = .75;
		} else {
			this.height = 1.0;
		}
		this.ground = null;
		this.vy = 0;
		this.dx = 0;
		this.facing_right = true;
		this.walking = false;
		this.player_default_height = IMAGES.get('sprites/player/stand.png').height;
		this.dead = false;
		this.ghost = false;
	}
	
	function update(scene, grid) {
		
		// Phase 1: apply y vector
		
		if (this.ghost) {
			this.x += this.dx;
			this.y += this.dy;
			this.dx = 0;
			this.dy = 0;
			this.ground = null;
		} else {
			
			effective_height = this.height * .9;
			
			if (this.ground != null) {
				// you are standing on ground. set Y to the ground value.
				this.y = this.ground.y;
				this.vy = 0;
			} else {
				this.vy += GRAVITY;
				//if ($abs(this.vy) > TERMINAL_VELOCITY) {
				//	this.vy = (this.vy < 0) ? -TERMINAL_VELOCITY : TERMINAL_VELOCITY;
				//}
				new_y = this.y + this.vy;
				col = $floor(this.x);
				if (this.vy < 0) {
					// you are flying up in the air
					// check to see if you bonk your head.
					top_y = new_y - effective_height;
					new_row = $floor(top_y);
					old_row = $floor(this.y - effective_height);
					bonks = false;
					for (row = old_row; row >= new_row; --row) {
						tile = grid[col][row];
						if (tile.blocking) {
							// BONK!
							bonks = true;
							this.vy = 0;
							this.y = row + 1 + effective_height + EPSILON;
							break;
						}
					}
					
					if (!bonks) {
						this.y = new_y;
					}
				} else {
					// you are falling down
					old_row = $floor(this.y);
					new_row = $floor(new_y);
					lands = false;
					for (row = old_row; row <= new_row; ++row) {
						tile = grid[col][row];
						if (tile.blocking) {
							this.y = tile.y + 0.0;
							this.ground = tile;
							lands = true;
							break;
						}
					}
					
					if (!lands) {
						this.y = new_y;
					}
				}
			}
			
			// Phase 2: apply x vector
			
			this.walking = false;
			if (this.dx != 0) {
				this.walking = true;
				this.facing_right = this.dx > 0;
				new_x = this.x + this.dx;
				old_col = $floor(this.x);
				new_col = $floor(new_x);
				if (old_col == new_col) {
					this.x = new_x;
				} else {
					bottom_y = $floor(this.y - EPSILON);
					top_y = $floor(this.y - effective_height);
					blocked = false;
					for (y = top_y; y <= bottom_y; ++y) {
						tile = grid[new_col][y];
						if (tile.blocking) {
							blocked = true;
						}
					}
					
					if (blocked) {
						if (this.dx > 0) {
							this.x = new_col - EPSILON;
						} else {
							this.x = new_col + 1 + EPSILON;
						}
					} else {
						this.x = new_x;
						if (this.ground != null) {
							new_ground = grid[new_col][$floor(this.y)];
							if (new_ground.blocking) {
								this.ground = new_ground;
							} else {
								this.ground = null;
							}
						}
					}
				}
				this.dx = 0;	
			}
		}
	}
	
	function render(rc, offset_x, offset_y) {
		
		if (this.type == 'player') {
			bottom = $floor(this.y * 40);
			height = $floor(this.height * 40);
			top = bottom - height;
			
			scale = 1.0 * height / this.player_default_height;
			flipped = this.facing_right;
			img = IMAGES.get_scaled('sprites/player/stand.png', scale, flipped);
			
			width = img.width;
			left = $floor(this.x * 40 - width / 2);
			
			$gfx_blit_image(img, left - offset_x, top - offset_y);
			
		} else {
			
			width = $floor(this.width * 40);
			left = $floor(this.x * 40 - width / 2);
			bottom = $floor(this.y * 40);
			height = $floor(this.height * 40);
			top = bottom - height;
			
			blue = this.type == 'player' ? 0 : 255;
			$gfx_draw_rectangle(left - offset_x, top - offset_y, width, height, 255, 0, blue, 255);
		}
	}
}